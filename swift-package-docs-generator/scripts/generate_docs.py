#!/usr/bin/env python3
"""
Generate or retrieve documentation for Swift package dependencies.
"""

import sys
import os
import json
import subprocess
import glob
import uuid
import shutil
from pathlib import Path


def error_exit(message):
    """Print error message and exit."""
    print(f"Error: {message}", file=sys.stderr)
    sys.exit(1)


def run_command(cmd, cwd=None, capture_output=True):
    """Run a shell command and return output."""
    try:
        result = subprocess.run(
            cmd,
            cwd=cwd,
            capture_output=capture_output,
            text=True,
            check=True
        )
        return result.stdout.strip() if capture_output else None
    except subprocess.CalledProcessError as e:
        error_exit(f"Command failed: {' '.join(cmd)}\n{e.stderr}")


def get_swift_dependency_list(xcodeproj_path):
    """Get dependency list using swift-dependency-list skill."""
    skill_script = Path.home() / ".claude/skills/swift-dependency-list/scripts/extract_xcode_dependencies.py"

    if not skill_script.exists():
        error_exit("swift-dependency-list skill not found")

    output = run_command(["python3", str(skill_script), xcodeproj_path])
    return json.loads(output)


def resolve_package_name(module_or_package, dependencies):
    """Resolve module name to package name using dependency list."""
    # Check if it's already a package name
    if module_or_package in dependencies:
        return module_or_package

    # Search for module in exported_modules
    for package_name, info in dependencies.items():
        if module_or_package in info.get("exported_modules", []):
            return package_name

    error_exit(f"Could not find package for module: {module_or_package}")


def find_package_in_derived_data(package_name, xcodeproj_path):
    """Find package directory in DerivedData."""
    # Extract project name from xcodeproj path
    project_name = Path(xcodeproj_path).stem

    # Search for DerivedData directory
    derived_data_pattern = f"{Path.home()}/Library/Developer/Xcode/DerivedData/{project_name}-*/SourcePackages/checkouts/{package_name}"
    matches = glob.glob(derived_data_pattern)

    if not matches:
        error_exit(f"Package '{package_name}' not found in DerivedData. Has the project been built?")

    return Path(matches[0])


def get_package_version(package_dir):
    """Extract package version from git tags."""
    # Try git describe first
    try:
        version = run_command(["git", "describe", "--tags"], cwd=package_dir)
    except:
        # Fall back to latest tag
        tags = run_command(["git", "tag", "--sort=-version:refname"], cwd=package_dir)
        if not tags:
            error_exit(f"No git tags found in {package_dir}")
        version = tags.split('\n')[0]

    # Parse version to major.minor
    version = version.lstrip('v')  # Remove 'v' prefix if present
    parts = version.split('.')
    if len(parts) >= 2:
        return f"{parts[0]}.{parts[1]}"
    return parts[0]


def find_readme(package_dir):
    """Find README file in package directory."""
    for filename in ["README.md", "README.txt", "README.markdown"]:
        readme_path = package_dir / filename
        if readme_path.exists():
            return readme_path
    return None


def generate_documentation(package_dir, package_name):
    """Run interfazzle to generate documentation."""
    # Generate unique output directory name
    output_dir = str(uuid.uuid4())

    try:
        # Run interfazzle
        run_command(
            ["interfazzle", "generate", "--output-dir", output_dir],
            cwd=package_dir,
            capture_output=False
        )

        # Concatenate all markdown files
        output_path = package_dir / output_dir
        markdown_files = sorted(output_path.glob("**/*.md"))

        if not markdown_files:
            error_exit(f"No markdown files generated by interfazzle")

        content_parts = []

        # Add generated docs
        for md_file in markdown_files:
            with open(md_file, 'r') as f:
                content_parts.append(f.read())

        # Add README if exists
        readme_path = find_readme(package_dir)
        if readme_path:
            content_parts.append("\n\n---\n\n# Package README\n\n")
            with open(readme_path, 'r') as f:
                content_parts.append(f.read())

        combined_content = "\n\n".join(content_parts)

        # Clean up temp directory
        shutil.rmtree(output_path)

        return combined_content

    except Exception as e:
        # Clean up temp directory on error
        temp_path = package_dir / output_dir
        if temp_path.exists():
            shutil.rmtree(temp_path)
        raise e


def main():
    if len(sys.argv) != 3:
        print("Usage: python3 generate_docs.py <module_or_package_name> <xcodeproj_path>")
        sys.exit(1)

    module_or_package = sys.argv[1]
    xcodeproj_path = sys.argv[2]

    # Validate xcodeproj path
    if not os.path.exists(xcodeproj_path):
        error_exit(f"Xcode project not found: {xcodeproj_path}")

    project_dir = Path(xcodeproj_path).parent
    docs_dir = project_dir / "dependency-docs"

    # Get dependency list and resolve package name
    print(f"Resolving package name for: {module_or_package}", file=sys.stderr)
    dependencies = get_swift_dependency_list(xcodeproj_path)
    package_name = resolve_package_name(module_or_package, dependencies)

    # Get package info
    package_info = dependencies[package_name]
    version = package_info.get("version", "unknown")

    # Parse version to major.minor
    version_parts = version.split('.')
    short_version = f"{version_parts[0]}.{version_parts[1]}" if len(version_parts) >= 2 else version_parts[0]

    # Check if docs already exist
    docs_filename = f"{package_name}-{short_version}.md"
    docs_path = docs_dir / docs_filename

    if docs_path.exists():
        print(f"Documentation already exists: {docs_path}", file=sys.stderr)
        print(docs_path)
        return

    # Find package in DerivedData
    print(f"Finding package '{package_name}' in DerivedData...", file=sys.stderr)
    package_dir = find_package_in_derived_data(package_name, xcodeproj_path)

    # Generate documentation
    print(f"Generating documentation for {package_name} {short_version}...", file=sys.stderr)
    content = generate_documentation(package_dir, package_name)

    # Save documentation
    docs_dir.mkdir(exist_ok=True)
    with open(docs_path, 'w') as f:
        f.write(content)

    print(f"Documentation generated successfully!", file=sys.stderr)
    print(docs_path)


if __name__ == "__main__":
    main()
